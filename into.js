// const and let -> allocate some space in memory to the variable where data can be stored/assigned
const accId = 1123 // cannot be redefined
let accEmail = "bhubnesh2002@gmail.com" // can be redefined
var accPassword = "8476"  // don't have variable scoping -> block scope and functional scope

// accId = 1124  // TypeError: Assignment to constant variable.


function change(){
     accEmail = "mikubro9@gmail.com"
     accPassword = "1234"

}


change()

console.log(accId)  // meh !
console.table([accId, accEmail,accPassword]) // this is good XD


"use strict";  // treat all JS code as the newer version

// alert() -> can be used in the browser window not in node


// dataTypes

/*
NOTE : JS is DYNAMICALLY TYPED LANGUAGE -> the dataType(memory allocation for the variable) is decided at the run time
Variable is of two types (based on storage and accessing of variable)
Primitive : call by value  -> when passing to a function a copy of the value is passed

 1. Numbers - Integers, floats
                const num = 10, float = 10.5
 2. Strings - Any data under single quote, double quote or backtick quote
                let str = "hello JS"
 3. Booleans - true or false value
                isLoggedIn = false
 4. Null - (stand-alone empty value) empty value or no value
                let temp = null
 5. Undefined - a declared variable without a value
                let empty
 6. Symbol - A unique value that can be generated by Symbol constructor
                const id = Symbol('123')
                const anotherID = symbol('123')
           but, id === anotherID // false

Non-primitive : call by reference -> when passing to a function a reference pointer is passed

1. Objects
    let batman = {
            power : "smart",
            speed : "slow",
            weapon : ["bomb","mob-car","bat-knife",...]
            }
2. Arrays
    const heroes = ["batman", "superman", "flash"]
3. Functions
        function print(){
            return f"{batman.weapon}"
        }
 */
// example of each data type
var batman = {
    power : "smart",
    speed : "slow",
    weapon : ["bomb","mob-car","bat-knife"]
}

const heroes = ["batman", "superman", "flash"]

function print(){
    return `Weapons: ${batman.weapon.join(", ")}`;
}// NOTE : `formated string ` --> comes handy many a times


function fun(){
    console.log("hello JS");
}

let age = 10

console.log(print())
console.log(typeof fun ) // output : object -> type  : object
console.log(typeof fun ) // output : undefined -> fun() its not a variable
console.log(typeof Symbol())  // output : symbol -> function : object
console.log(typeof undefined) // output : undefined -> type : undefined
console.log(typeof null) // output : object -> type : object
console.log(typeof print() ) // output : string -> because we are returning string

// 3
// CONVERSION OPERATION

let score = 33
let Score = "33"
let WrongScore = "33acb"
let bool = Boolean(score)

console.log(typeof " ") // output : string
console.log(typeof "")  // output : string -> sometimes nothingness is also a string
console.log(Number(""))  // output : 0 -> similar to null behaviour
console.log(typeof(Score))  // output : string
console.log(typeof(Number(Score))) // output : number
console.log(typeof WrongScore) // output : number
console.log(WrongScore) // output : NAN(Not A Number) -> but type is number XD
console.log(null) // output : 0 -> here empty == 0 , JS logic XD
console.log(undefined) // output : NAN
console.log(true) // output = true
console.log(false) // output = false
console.log(Boolean(score)) // output : true
console.log(Boolean(WrongScore)) // output : true
console.log(Boolean(0)) // output : false
console.log(Boolean(null)) // output : false -> nothingness is false -> false object
console.log(Boolean(undefined)) // output : false
console.log(Boolean(" ")) // output : true -> emptiness is true
console.log(Boolean("")) // output : false -> nothingness is false


// NOTE : 0, false, null, undefined, emptyString -> false
//        except these all other dataTypes are true


//4
// memory management
/*
Stack : store primitive dataType -> copy of value is give after storing the value
Heap : store Non-primitive dataType -> reference pointer is returned after saving the value
*/

let myName = "Maharana"
let myWife  = myName

myWife = "Choudry"

console.table([myName, myWife])
//NOTE : here a copy of the myName is give to the myWife
//       when myWife got updated then myName didn't get affected

let userOne = {
    office : "Google"
}

let userTwo = userOne

userTwo.office = "Amazon"

console.table([userOne.office, userTwo.office])
//NOTE : here userOne and userTwo are accessing the same memory location
//       when userTwo update the value userOne read the updated value


//5
// OPERATIONS

let val = 3
let negVal = -val

// basic arithmetic operations
console.log(negVal) // output : -3
console.log(negVal%-2) // output : -1  -> surprise module have the sign of the first operant
console.log(negVal*2) // output : -6
console.log(negVal/2) // output : -1.5
console.log(negVal+2) // output : -1
console.log(negVal-2) // output : -5
console.log(negVal**2) // output : 9
console.log(negVal%2) // output : -1

// type casting in string

let str = "2"

console.log(2 + 2) // output : 4
console.log(2 + "2") // output : 22
console.log("2" + 2) // output : 22
console.log(2 + 2 + "2") // output : 42 -> left to right calculation
console.log("2" + 2 + 2) // output : 222
console.log(3 + 4 * 5 - 3) //output : 20 -> execute according to operator priority [*,/,% > +,-]


//bad operations
console.log(+true) // output : 1
console.log(+false) // output : 0
console.log(+"") // output : 1

let n_1, n_2, n_3

n_1 = n_2 = n_3 = 10

console.table([n_1, n_2, n_3])


//6
// COMPARISONS

// basic relational operator
console.log(2 != 1) // output : true
console.log(2 == 1) // output : false

// basic comparison operations
console.log(2 < 1) // output : true
console.log(2 > 1) // output : true
console.log(2 >= 2) // output : true
console.log(2 <= 2) // output : true

// comparing different dataTypes

console.log("2" > 1) // output : true
//NOTE : relational operators typecast the value before comparing

console.log("2" == 2) // output : true -> typecasting of string to number
console.log("2" === 2) // output : false -> no typecasting
//NOTE : relation operation  work same as comparison operator when operand is a not null


console.log(null > 0) // output : false
console.log(null == 0) // output : false
console.log(null >= 0) // output : true -> null converted to 0
console.log(null != 0) // output : true -> null not converted
/*
NOTE : this unexpected behaviors of null comparison is dur to the fact that

       relational operator[== and !=] work differently form comparison operator[ <,>,<=,>= ]
       comparison operator convert the null to a number before comparing
but,   relational operator don't do type casting before comparing
*/

console.log(undefined > 0) // output : false
console.log(undefined == 0) // output : false
console.log(undefined >= 0) // output : false
console.log(undefined != 0) // output : true
//NOTE : no conversion for undefined values


//7
//Strings

// String Concatenation
let str_1 = "hello "
const str_2 = new String('World') // when created a String object then we get the prototype functions
const str_3 = str_1 + str_2

console.log(str_2) // output : [String: 'World'] -> returns string object
console.log(str_1) // output : hello -> return string
//__proto__
//these are set of the methods available in the Sting class object

console.table([str_1.length, str_3.toUpperCase(), str_3]) // .toUpperCase -> is a prototype function
//NOTE : str_3.toUpperCase() -> this doesn't change the original value of the string bcz
//                               string is a primitive dataType, operation perform on copy on original value

console.log(str_3.charAt(3)) // output : 3 -> base index 1
console.table([str_3.indexOf("k"), str_3.indexOf([null]), str_3.indexOf([""])]) // output : -1 -> element not found
                                                                      // output : 0 -> why ?


//subString(firstIndex,lastIndex)
const name  = "Bhubnesh Maharana"
let firstName = name.substring(0,8) // firstName = Bhubnesh -> last index is exclusive
let lastName = name.substring(9,name.length)
console.table([name, firstName, lastName])


//slice(startingIndex,LastIndex) -> unlike subString can take negative index values
//                                  Negative Index value starts from end of the string
let my_name = name.slice(-8)
console.table(my_name)
console.table([ name.slice(-8), name.slice(0,8), name.slice(-8,-5) , name.slice(-8)])

// split() -> break the string into array of string
const userNameOne = "_Bhubnesh__Maharana_"
let U_name = userNameOne.split("_")
console.log(U_name)

// trim() _. trimEnd() / trimStart()
const userNameTwo = "        Bhubnesh   Maharana      "
U_name = userNameTwo.trim() // trim the starting white spaces
console.log(U_name)

// replace()
let email = "bhubnesh2002@gmail%20com"
const valid_mail = email.replace("%20",".")
console.log(valid_mail)

// include()
console.log(email.includes("gmail.com"))
console.log(valid_mail.includes("gmail.com"))


// `String interpolation ${place-holders}`
console.log(`${myName} is my sur name .`) // -> this is a formatted string


//8
//NUMBERS
const number = 23
const obj_number = new Number(23) // number object comes with some method like string object
console.log(number)
console.log(obj_number)

//toString()
console.log(number.toString().length) // output : 2 -> once converted to string we can use string methods
//toFixed
console.log(number.toFixed(2)) // output : 23.00 -> fix the number of decimal value
//toPrecision()
console.log(number.toPrecision(3)) // output : 23.0
console.log(number.toPrecision(1)) // output : 2e+1 -> after the precision value it will convert the rest of the value into exponential

//toLocalString()
const money = 1000000000
console.log(money.toLocaleString()) // output : 1,00,00,00,000
console.table([money.toLocaleString(), money.toLocaleString('en-IN')])

//MAX_VALUE() / MIN_VALUE()

//MATHS _. Library comes inbuilt(default with the JS
console.log(Math) // it will give u list of the methods of the Maths liberary

//abs() - absolute value -> always return positive value
console.table([Math.abs(-4), Math.abs(4)])

//round(), floor() and ceil()
console.table([Math.round(6.7), Math.round(6.1), Math.ceil(6.1), Math.floor(6.7)])

//min() and max()
console.table([Math.min(9,2,0,7,4), Math.max(9,2,0,7,4)])

//random()
console.log(Math.random()) // output -> return a value from 0 to 1
console.log((Math.random()*10) + 1)
console.log(Math.round((Math.random()*10) + 1))

const min_1 = 10
const max_1 = 20
console.log(Math.random() * (max_1-min_1)) // values between [0-10
console.log(Math.random() * (max_1-min_1 + 1)) // values between [1-10]
console.log((Math.random() * (max_1-min_1 + 1)) + min_1) //values between [min - max]
console.log((Math.floor((Math.random() * (max_1-min_1 + 1)) + min_1))) //values between [min-max].floor


//9
//DATES

let myDate = new Date()
console.log(myDate) // output : 2024-02-12T10:15:50.534Z
console.log(typeof myDate)  // type : object

// method of the object Date
let dateString_1 = myDate.toString() // output : 'Mon Feb 12 2024 15:53:55 GMT+0530 (India Standard Time)'
let dateString_2 = myDate.toDateString() // output : 'Mon Feb 12 2024'
let dateString_3 = myDate.toLocaleDateString()  // output : '12/2/2024'
let dateString_4 = myDate.toJSON() // output :  '2024-02-12T10:19:03.444Z'
let dateString_5 = myDate.toLocaleTimeString()  // output : '3:53:55 pm'
let dateString_6 = myDate.toUTCString() // output : 'Mon, 12 Feb 2024 10:23:55 GMT'

console.table([dateString_1, dateString_2, dateString_3,dateString_4, dateString_5, dateString_6])

const myCreatedDate_1 = new Date(2023,0,23, 5 ,3) // "YYYY-MM-DD-HH-MM-SS"
console.log(myCreatedDate_1.toLocaleString()) // output : 23/1/2023, 12:00:00 am
//NOTE : moths start from 0 in JS XD

let myCreatedDate_2 = new Date("2023-00-2") //output : Invalid Date
myCreatedDate_2 = new Date("2020-01-12") // "YYYY-MM-DD"
myCreatedDate_2 = new Date("12-10-2023") // "MM-DD-YYYY"
console.log(myCreatedDate_2.toLocaleString()) // output :12/1/2020, 5:30:00 am

//now() -> return the current time in  milliseconds
let myTimeStamp = Date.now() // for pooling and choosing the winner
console.log(myTimeStamp) // output : 1707734343585 ( this is the millisecond time reference to January 1, 1970, UTC

// how to compare this tie to a date
//getTime()
console.log(myDate.getTime())

// convert it to secound
console.log(Date.now()/1000) // output : 1707734708.946
console.log(Math.round(Date.now()/1000)) // output : 1707734708

//extract hour(getHour()), day(getDay()), month(getMonth()) and year(getYear()) form the date
let hh =  myDate.getHours()
let dd =  myDate.getDay() +1 // [0-6]
let mm =  myDate.getMonth() +1 // [0-11]
let yyyy =  myDate.getFullYear()
console.log(myDate.toLocaleString())
console.table([hh, dd, mm, yyyy])

//toLocalString() -> it have many key:value pairs related to to local time,currncy,language, etc
myDate.toLocaleString('defalut',{
    weekday:"narrow",
})
console.log(myDate)


//____________________________________________________________________________________________________________________>

//10
//ARRAY-> these are dynamic data structure which can store any type of data
let myArr = ['1',1,[10,20,30],true,'a',null,undefined,,] // output : [ '1', 1, [ 10, 20, 30 ], true, 'a', null, undefined, <1 empty item> ]
const myArr_1 = new Array(1,2,3,4,5)
//Note: we can store any dataType taught till now  in array
console.table([myArr,myArr_1])

//accessing the array - 0 based indexing
console.log(myArr[5]) // output : null

/*
NOTE : JavaScript array-copy operations create shallow copies.
 shallow copy - share shame reference or memory location ex.var
deep copy - don't share shame reference or memory location  ex. object
*/

// Array Methord

//push()
myArr_1.push("bhubnesh")
console.log(myArr_1)

//pop()
myArr_1.pop()
console.log(myArr_1)

// NOTE : unshift and shift are not optimal in all cases
// unshift and shift ate CPU intensive function as adding element to the start of the array
// cause shifting all existing element index which might make the program slow
//unshift() -> add the element at the start
myArr_1.unshift("My Array :")
console.log(myArr_1)

//unshift() -> remove the element at the start
myArr_1.shift()
console.log(myArr_1)

//includes()
console.log(myArr_1.includes(9)) // output : false
console.log(myArr_1.includes(3)) // output : true

//indexOf()
console.log(myArr_1.indexOf(9)) // output : -1
console.log(myArr_1.indexOf(3)) // output : 2

//join() -> console.log(myArr_1.includes(9)) // output : false
let newArray = myArr_1.join('+')
console.log(typeof newArray) // output : string
console.log(newArray) // output : 1+2+3+4+5


//slice(firstIndex, lastIndex) and Splice(firstIndex, numberOfElements)

let arr = [1,2,3,4,5,6,7,8,9]
let arr_1 = arr.slice(2, 4) // last index is exclusive
console.log(arr_1)


let arr_2 = arr.splice(2,6) // it mutate the original array
console.log(arr) // output : [ 3, 4, 5, 6, 7, 8 ]
console.log(arr) // output : [ 1, 2, 9 ]

//part - 2

const marvel_heroes = ["thor","Ironman","spiderman"]
const dc_heroes = ["superman","flash", "batman"]

//push()
console.log(marvel_heroes) // output : [ 'thor', 'Ironman', 'Spider-Man', [ 'superman', 'flash', 'batman' ] ]
// here the instead of merging of two array one array is store inside the other
 console.log(typeof marvel_heroes.push(dc_heroes)) // output : number
 console.log(marvel_heroes.push(dc_heroes)) // output : 5 -> nos of element in the array

// access the neseted array element
 console.log(marvel_heroes[3][2])

//remove the old array
marvel_heroes.splice(3,marvel_heroes.length)

//concat() -> merge two array + return a new array (copy)
let Heroes = marvel_heroes.concat(dc_heroes) // it doesnot mutate the original array
console.log(Heroes)

//spread oerator -> ...  : it can merge two or more arrays with a ease, mostly used in react
Heroes = [...dc_heroes, ...marvel_heroes, "bhubnesh"]
console.log(Heroes)

//flat(death) -> beak the nested array and return the single array with all the elements
const nested_arr = [1,2,3,[4,5,6,[7,8]],9]
let simple_arr = nested_arr.flat(2) // The depth level specifying how deep a nested array structure should be flattened
console.log(simple_arr)

//when we recive the input is a non array format
//isArray() -> return  boolean value which tell if it a raay or not
console.log(Array.isArray("Bhubnesh"))

//from() -> it will convert the inut into array
console.log(Array.from("Bhubnesh")) // output : ['B', 'h', 'u','b', 'n', 'e','s', 'h']


console.log(Array.from({name:"Bhubnesh"})) // output : []
//NOTE : when passing a key:"value" pair then we need to specify which part needs the conversion

//of() -> creates a new Array instance from a variable number of arguments
const a = [1,2,3]
const b = "Bhubnesh"
const c = 10

console.log(Array.of(a,b,c))


//11
//OBJECTS

const sym = Symbol("key")

//Declaration
// object literal
const obj = {
    key:"value",
    "string":"hello JS",
    [sym] : "Symbol as key", //using symbols as key in object
    sym : "String key",
    name: "bhubnesh",
    location:"vijayvada",
    email:"bhubnesh2002@gmail.com",
    isLoggedIn : false,
    lastLoggedIn: ["Monday","Saturday"]
}

//Accessing
//1. (.) operator, can be used to access symbol or string key values
console.log(obj.key) // output : value
// console.log(obj."string") // output :SyntaxError: Unexpected string

//2. general methord : square brackets [] can be used to pass any type of key
console.log(obj["name"]) // output : bhubnesh
// NOTE : ker are store in object as the string
console.log(obj)

//Updating
obj.isLoggedIn = true
console.log(obj.isLoggedIn) // output : true

//add key to the object
obj.new_key = "new value"

// freeze() -> object's prototype cannot be re-assigned.
Object.freeze(obj) // used to lock the sensitive info like roll no adhar no
obj.email = "bhubnehs@wrongmail.com"
console.log(obj.email)
obj.lastLoggedIn[1] ="Friday"  // object's prototype cannot be re-assigned. any nested object,array can be modified
console.log(obj)


//seal() -> no new properties acn be added into the function
let another_obj = {
    key:"value",
    name: "bhubnesh",
    location:"vijayvada",
    email:"bhubnesh2002@gmail.com",
    isLoggedIn : false,
    lastLoggedIn: ["Monday","Saturday"]
}
Object.seal(another_obj)

another_obj.email = "bhubnehs@wrongmail.com"
another_obj.new_key = "new_value"
console.log(another_obj)

//function in objects
let fun_object = {
    isLogged :  true,
    name : "Bhubnesh",
}
//this - is used to access the properties of the parent
fun_object.message = function () {
    console.log(`${this.name} Welcome to JS`) // output : Bhubnesh Welcome to JS
}
fun_object.message()
console.table([fun_object.message , fun_object.message()])


//2.
const snapChartUser = new Object() // createt a non sliliton object

snapChartUser.id = "1234"
snapChartUser.name = 'Bhubnesh'
snapChartUser.isLoggedIn = false

console.log(snapChartUser)

const db =  {
    db_id : "12ab",
    snapChart: snapChartUser,
    location: "vijayvada",
    size : 1000000,
    isEmpty : false ,

}

console.log(db.snap?.name) // ? operator is used is if-else statement is the property exist or not
console.log(db.snapChart?.name)

//merging update
const user_0 = {
    id:"1",
    name: "Mohit"
}
const user_1 = {
    id:"2",
    name:"Bhubnesh"
}

//1.
let User_object = {...user_0} // output : { id: '1', name: 'Mohit' }
console.log(User_object)
 User_object = {...user_0 ,...user_1 } // output : { id: '2', name: 'Bhubnesh' }
//NOTE
console.log(User_object)

//2.


//3.